<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>0 Nexus ðŸœ‹</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
          }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
    </style>
  </head>
  <body class="font-sans">
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        // CSS2DRenderer is used to render HTML elements (labels) on top of the 3D scene
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        // GLTFLoader is used to load 3D models in GLB/GLTF format
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Scene variables
        let camera, scene, renderer, labelRenderer;
        let doors = []; // Array to hold the 3D door groups
        let hub;
        
        // Raycaster and mouse vector for handling click events
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let roomSize;

        // Variables for keyboard controls (W, A, S, D)
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let rotateLeft = false;
        let rotateRight = false;
        const speed = 0.5; // Controls how fast the camera moves
        const rotationSpeed = 0.01; // Controls how fast the camera rotates

        // Base path for 3D models stored on GitHub
        const modelBasePath = 'https://raw.githubusercontent.com/zakdegarmo/MyOS/main/%F0%9F%9C%8BMyWebsite/models/';
        // Array of objects, each containing a model path and a link for a door
        const doorData = [
            { id: 1, model: `${modelBasePath}glyph_self.glb`, link: 'https://zakdegarmo.github.io/MyOntology/' },
            { id: 2, model: `${modelBasePath}glyph_thought.glb`, link: 'https://zakdegarmo.github.io/ZaksNotepad/index.html' },
            { id: 3, model: `${modelBasePath}glyph_logic.glb`, link: 'https://3-d-file-explorer.vercel.app/' },
            { id: 4, model: `${modelBasePath}glyph_unity.glb`, link: 'https://ai.studio/apps/drive/1p-fpFOyaUNJHHFCzgQ6x9aqIkt5xi0D9'},
            { id: 5, model: `${modelBasePath}glyph_existence.glb`, link: 'https://ai.studio/apps/drive/1zRyunFnZjxXt3TNy2uwBGcxze-pFhZ-w' },
            { id: 6, model: `${modelBasePath}glyph_improvement.glb`, link: 'https://data-vis-eosin.vercel.app/' },
            { id: 7, model: `${modelBasePath}glyph_mastery.glb`, link: 'https://ai.studio/apps/drive/1XRz8dvokYQyVhmuBG_yMZF4ielHllS2-' },
            { id: 8, model: `${modelBasePath}glyph_resonance.glb`, link: 'https://3d-ttf.vercel.app/' },
            { id: 9, model: `${modelBasePath}glyph_transcendence.glb`, link: 'https://hyper-aether-pilgrim.vercel.app/' }
        ];

        // Initializes the 3D scene, renderer, and camera
        function init() {
            scene = new THREE.Scene();
            // Adds a fog effect to the scene
            scene.fog = new THREE.FogExp2(0x000000, 0.005);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none'; // Allows clicks to pass through to the main canvas
            document.body.appendChild(labelRenderer.domElement);

            // Defines the size of the wireframe room
            roomSize = 750;
            const wallGeometry = new THREE.CylinderGeometry(roomSize / 2, roomSize / 2, roomSize, 9, 1, true);
            const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true, side: THREE.BackSide });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            scene.add(walls);

            // Creates the floor
            const floorSize = roomSize * 2;
            const floorGeometry = new THREE.CircleGeometry(floorSize / 2, 9);
            const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, side: THREE.DoubleSide });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2; // Rotates the plane to be horizontal
            floor.position.y = -(roomSize / 2);
            scene.add(floor);

            // Sets up the camera and its initial position
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, -(roomSize / 2) + 2, roomSize * 0.4); // Locks the camera to a fixed height for "walking"

            // Adds lighting
            const ambientLight = new THREE.AmbientLight(0x444444, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.5, 1000);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Creates the central hub
            const hubGeometry = new THREE.IcosahedronGeometry(15, 3);
            const hubMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
            hub = new THREE.Mesh(hubGeometry, hubMaterial);
            const hubHeight = 15 * 2;
            const hoverOffset = 5;
            hub.position.y = -(roomSize / 2) + (hubHeight / 2) + hoverOffset;
            hub.userData = { id: 0, name: "Back to Previous" };
            scene.add(hub);
            
            createDoors();

            // Adds event listeners for window resize, mouse clicks, and keyboard input
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('click', onClick);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }

        // Handles key presses to start or stop movement
        function onKeyDown(event) {
            switch (event.key.toLowerCase()) {
                case 'w':
                    moveForward = true;
                    break;
                case 's':
                    moveBackward = true;
                    break;
                case 'a':
                    moveLeft = true;
                    break;
                case 'd':
                    moveRight = true;
                    break;
                case 'q':
                    rotateLeft = true;
                    break;
                case 'e':
                    rotateRight = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.key.toLowerCase()) {
                case 'w':
                    moveForward = false;
                    break;
                case 's':
                    moveBackward = false;
                    break;
                case 'a':
                    moveLeft = false;
                    break;
                case 'd':
                    moveRight = false;
                    break;
                case 'q':
                    rotateLeft = false;
                    break;
                case 'e':
                    rotateRight = false;
                    break;
            }
        }

        // Loads and positions the 3D door models
        function createDoors() {
            const loader = new GLTFLoader();
            const doorMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x00ffff,
                emissiveIntensity: 0.2,
                wireframe: true
            });

            doorData.forEach((data, i) => {
                const doorGroup = new THREE.Group();
                doorGroup.userData = { id: data.id, link: data.link };
                
                doors.push(doorGroup);
                scene.add(doorGroup);

                loader.load(data.model, (gltf) => {
                    const model = gltf.scene;
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.material = doorMaterial;
                        }
                    });
                    // Adjusts the model's scale to a consistent size
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const scale = 20 / Math.max(size.x, size.y, size.z);
                    model.scale.set(scale, scale, scale);
                    
                    doorGroup.add(model);
                });
            });
        }

        // Resizes the renderer and camera when the browser window is resized
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Handles click events to detect which object was clicked and navigate
        function onClick(event) {
            event.preventDefault();
            // Calculates mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Casts a ray from the camera through the mouse position
            raycaster.setFromCamera(mouse, camera);
            // Finds all objects the ray intersects
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                let selectedObject = intersects[0].object;
                // Traverses up the parent hierarchy to find the main door group
                while (selectedObject.parent && !selectedObject.userData.link) {
                    selectedObject = selectedObject.parent;
                }
                
                const { id, link } = selectedObject.userData;

                if (id === 0) {
                    // Special case for the hub to go back
                    setTimeout(() => { window.history.back(); }, 500);
                } else if (link && link !== '#') {
                    // Navigates to the linked URL
                    window.location.href = link;
                } else {
                    console.log(`Clicked on Portal ${id}, but no link is assigned.`);
                }
            }
        }

        // The main animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Updates camera position based on keyboard input
            if (moveForward) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.addScaledVector(direction, speed);
            }
            if (moveBackward) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.addScaledVector(direction, -speed);
            }
            if (moveLeft) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                const rightVector = direction.cross(camera.up);
                camera.position.addScaledVector(rightVector, -speed);
            }
            if (moveRight) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                const rightVector = direction.cross(camera.up);
                camera.position.addScaledVector(rightVector, speed);
            }

            // Updates camera rotation based on keyboard input
            if (rotateLeft) {
                camera.rotation.y += rotationSpeed;
            }
            if (rotateRight) {
                camera.rotation.y -= rotationSpeed;
            }
            
            // Ensures the camera stays at a fixed "walking" height
            camera.position.y = -(roomSize / 2) + 2;
            // Prevents unwanted vertical camera rotation from other inputs
            camera.rotation.x = 0;
            camera.rotation.z = 0;

            const time = Date.now() * 0.0005;
            
            // Animates the doors (positions, rotation, and pulsing scale)
            doors.forEach((doorGroup, i) => {
                const angle = time * 0.5 + (i / doorData.length) * Math.PI * 2;
                const doorRadius = roomSize * 0.5;
                const doorHeight = 50;
                const hoverOffset = 10;
                
                // Calculates the position in a circle around the center
                doorGroup.position.x = Math.cos(angle) * doorRadius;
                doorGroup.position.z = Math.sin(angle) * doorRadius;
                // Adds a vertical sine wave for a hovering effect
                doorGroup.position.y = -(roomSize / 2) + (doorHeight / 2) + hoverOffset + Math.sin(angle * 2.5 + i) * 5;
                // Makes the doors face the central hub
                doorGroup.lookAt(new THREE.Vector3(0, doorGroup.position.y, 0));

                if (doorGroup.children.length > 0) {
                    // Makes the model pulse in scale
                    const pulseScale = 1 + Math.sin(time * 5 + i) * 0.02;
                    doorGroup.children[0].scale.set(pulseScale, pulseScale, pulseScale);
                }
            });

            // Makes the central hub always face the camera
            hub.lookAt(camera.position);

            // Renders the scene for both 3D and 2D elements
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        init();
        animate();
    </script>
  </body>
</html>