<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>0 Nexus ðŸœ‹</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
          }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
    </style>
  </head>
  <body class="font-sans">
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let camera, scene, renderer, labelRenderer;
        let doors = [];
        let hub;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let roomSize;

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let rotateLeft = false;
        let rotateRight = false;
        let lookUp = false;
        let lookDown = false;
	let moveUp = false;
	let moveDown = false;
        const speed = 0.5;
        const rotationSpeed = 0.01;
        const verticalRotationSpeed = 0.01;
        let cameraPivot;

        const modelBasePath = 'https://raw.githubusercontent.com/zakdegarmo/MyOS/main/%F0%9F%9C%8BMyWebsite/models/';
        const doorData = [
            { id: 1, model: `${modelBasePath}glyph_self.glb`, link: 'https://zakdegarmo.github.io/MyOntology/' },
            { id: 2, model: `${modelBasePath}glyph_thought.glb`, link: 'https://zakdegarmo.github.io/ZaksNotepad/index.html' },
            { id: 3, model: `${modelBasePath}glyph_logic.glb`, link: 'https://3-d-file-explorer.vercel.app/' },
            { id: 4, model: `${modelBasePath}glyph_unity.glb`, link: 'https://hyper-aether-pilgrim.vercel.app/'},
            { id: 5, model: `${modelBasePath}glyph_existence.glb`, link: 'https://atom-vis.vercel.app/' },
            { id: 6, model: `${modelBasePath}glyph_improvement.glb`, link: 'https://data-vis-eosin.vercel.app/' },
            { id: 7, model: `${modelBasePath}glyph_mastery.glb`, link: 'https://3d-ttf.vercel.app/' },
            { id: 8, model: `${modelBasePath}glyph_resonance.glb`, link: 'https://nexus-page-editor.vercel.app/' },
            { id: 9, model: `${modelBasePath}glyph_transcendence.glb`, link: '//new nexus links go here for depth traversal' }//new nexus links go here for depth traversal
        ];

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.005);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

             roomSize = 250;
            const wallGeometry = new THREE.IcosahedronGeometry(roomSize, roomSize/5);
            const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true, side:THREE.DoubleSide });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            scene.add(walls);


            const floorSize = roomSize * 2;
            const floorGeometry = new THREE.CircleGeometry(floorSize / 2, 9);
            const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, side: THREE.DoubleSide });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -(roomSize / 2);
            scene.add(floor);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            
            // Create a pivot object to handle camera movement and horizontal rotation
            cameraPivot = new THREE.Object3D();
            cameraPivot.add(camera);
            scene.add(cameraPivot);
            cameraPivot.position.set(0, -(roomSize / 2) + 2, roomSize * 0.4);

            const ambientLight = new THREE.AmbientLight(0x444444, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.5, 1000);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            const hubGeometry = new THREE.IcosahedronGeometry(15, 3);
            const hubMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
            hub = new THREE.Mesh(hubGeometry, hubMaterial);
            const hubHeight = 15 * 2;
            const hoverOffset = 5;
            hub.position.y = -(roomSize / 2) + (hubHeight / 2) + hoverOffset;
            hub.userData = { id: 0, name: "Back to Previous" };
            scene.add(hub);
            
            createDoors();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('click', onClick);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }

        function onKeyDown(event) {
            switch (event.key.toLowerCase()) {
                case 'w':
                    moveForward = true;
                    break;
                case 's':
                    moveBackward = true;
                    break;
                case 'd':
                    moveLeft = true;
                    break;
                case 'a':
                    moveRight = true;
                    break;
                case 'q':
                    rotateLeft = true;
                    break;
                case 'e':
                    rotateRight = true;
                    break;
                case 'f':
                    lookUp = true;
                    break;
                case 'r':
                    lookDown = true;
                    break;
                case 'z':
                    moveDown = true;
                    break;
                case 'c':
                    moveUp = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.key.toLowerCase()) {
                case 'w':
                    moveForward = false;
                    break;
                case 's':
                    moveBackward = false;
                    break;
                case 'd':
                    moveLeft = false;
                    break;
                case 'a':
                    moveRight = false;
                    break;
                case 'q':
                    rotateLeft = false;
                    break;
                case 'e':
                    rotateRight = false;
                    break;
                case 'f':
                    lookUp = false;
                    break;
                case 'r':
                    lookDown = false;
                    break;
                case 'z':
                    moveDown = false;
                    break;
                case 'c':
                    moveUp = false;
                    break;
            }
        }

        function createDoors() {
            const loader = new GLTFLoader();
            const doorMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x00ffff,
                emissiveIntensity: 0.2,
                wireframe: true
            });

            doorData.forEach((data, i) => {
                const doorGroup = new THREE.Group();
                doorGroup.userData = { id: data.id, link: data.link };
                
                doors.push(doorGroup);
                scene.add(doorGroup);

                loader.load(data.model, (gltf) => {
                    const model = gltf.scene;
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.material = doorMaterial;
                        }
                    });
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const scale = 20 / Math.max(size.x, size.y, size.z);
                    model.scale.set(scale, scale, scale);
                    
                    doorGroup.add(model);
                });
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onClick(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                let selectedObject = intersects[0].object;
                while (selectedObject.parent && !selectedObject.userData.link) {
                    selectedObject = selectedObject.parent;
                }
                
                const { id, link } = selectedObject.userData;

                if (id === 0) {
                    setTimeout(() => { window.history.back(); }, 500);
                } else if (link && link !== '#') {
                    window.location.href = link;
                } else {
                    console.log(`Clicked on Portal ${id}, but no link is assigned.`);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Get the camera's world direction for movement
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);

            // Handle horizontal movement on the cameraPivot
            if (moveForward) {
                cameraPivot.position.addScaledVector(direction, speed);
            }
            if (moveBackward) {
                cameraPivot.position.addScaledVector(direction, -speed);
            }
            if (moveLeft) {
                const rightVector = new THREE.Vector3().crossVectors(direction, cameraPivot.up);
                cameraPivot.position.addScaledVector(rightVector, speed);
            }
            if (moveRight) {
                const rightVector = new THREE.Vector3().crossVectors(direction, cameraPivot.up);
                cameraPivot.position.addScaledVector(rightVector, -speed);
            }

            // Horizontal rotation on the pivot
            if (rotateLeft) {
                cameraPivot.rotation.y += rotationSpeed;
            }
            if (rotateRight) {
                cameraPivot.rotation.y -= rotationSpeed;
            }

            // Vertical rotation on the camera itself
            if (lookUp) {
                camera.rotation.x = Math.max(-Math.PI / 2, camera.rotation.x - verticalRotationSpeed);
            }
            if (lookDown) {
                camera.rotation.x = Math.min(Math.PI / 2, camera.rotation.x + verticalRotationSpeed);
            }

            const time = Date.now() * 0.0005;
            
            doors.forEach((doorGroup, i) => {
                const angle = time * 0.2 + (i / doorData.length) * Math.PI * 2;
                const doorRadius = roomSize * 0.5;
                const doorHeight = 50;
                const hoverOffset = 10;
                
                doorGroup.position.x = Math.cos(angle) * doorRadius;
                doorGroup.position.z = Math.sin(angle) * doorRadius;
                doorGroup.position.y = -(roomSize / 2) + (doorHeight / 2) + hoverOffset + Math.sin(angle * 2.5 + i) * 5;
                doorGroup.lookAt(new THREE.Vector3(0, doorGroup.position.y, 0));

                if (doorGroup.children.length > 0) {
                    const pulseScale = 1 + Math.sin(time * 5 + i) * 0.02;
                    doorGroup.children[0].scale.set(pulseScale, pulseScale, pulseScale);
                }
            });

        hub.lookAt(camera.position);
	//cameraPivot.position.y = -100;
	const verticalSpeed = 0.5;
            if (moveUp) {
                cameraPivot.position.y += verticalSpeed;
            }
            if (moveDown) {
                cameraPivot.position.y -= verticalSpeed;
            }

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        init();
        animate();
    </script>
  </body>
</html>